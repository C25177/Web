# es

## 简介

es 与 js 的关系就是，前者是后者的规范，后者是前者的一种实现

## 环境配置

### nodejs

nodejs 的下载安装与一般的软件无异，从官网找到并且下载安装就好

### npm

需要使用镜像下载： [镜像地址](https://npmmirror.com/)

直接在终端执行下列命令就可完成安装

```shell
npm install -g cnpm --registry=https://npmmirror.com/
```

## 语法

### let关键字

特点

- 声明的变量只在当前的代码块中有效
- 不满足变量提升，也就是必须在声明之后使用变量，不然会报错
- 不允许重复声明同一个变量


```es6
{
  let a = 0;
}
a = 1; // 报错
```

### const关键字

特点

- 声明之后变量不可改变
- 声明时必须初始化
- 不满足变量提升，也就是必须在声明之后使用变量，不然会报错
- 只在当前的代码块中有效
- 不允许重复声明同一个变量

```es6
const a = 1;
a = 2; // 报错
```

### 变量解构赋值

解构可以用于对象，也可以很方便的将现有的对象的方法赋值到某个变量，对象的顺序没有要求，但是必须与属性同名才能得到正确的值

```JavaScript
var {age, name} = {name:"1", age:10};
console.log(name, age);
```

### 字符串扩展

- 在 es6 中增加了字符串对 `unicode` 字符码的支持，可以在代码中使用 `\uxxx` 来表示一个字符
  - `unicode` 码即统一码，是计算机科学领域里的一项业界标准，包括字符集，编码方案等， `unicode` 是为了解决传统的字符编码方案的局限而产生的，为每种语言的每个字符都设定了统一并且唯一的二进制编码
- 利用 `for...of` 语句实现字符串的遍历
- 模板字符串，是增强版的字符串，使用反引号 ` 标记，可以当作普通字符串使用，也可用来定义多行字符串，或者在字符串中嵌入变量
- `include()` 表示字符串中是否包含参数字符串，返回布尔值，支持第二个参数，表示开始搜索的位置，默认为0
- `srartsWith()` 返回布尔值，表示字符串是否以参数字符串开头，同上
- `endsWith()` 返回布尔值，表示字符串是否以参数字符串结尾，同上
- `repeat()` 返回一个由源字符串重复 `n` 次的字符串
- `padStart()` 如果不够指定长度，在头部补全
- `padEnd()` 如果不够指定长度，在尾部补全
- `trimStart()` 消除字符串头部的空格，返回新字符串，不改变源字符串
- `trimEnd()` 消除字符串头部的空格，同上
- `at()` 返回指定位置的字符，支持负索引

### 数组扩展

- 扩展运算符，三个点，将一个数组转为用逗号分割的参数序列
  - 将数组转为函数的参数，不需要再使用 `apply` 方法了
  - 作为合并数组的新写法
- `Array.from()` 用于将类数组转为真正的数组，常见类数组有三种
  - arguments
  - 元素集合
  - 类似数组的对象，但是书写要求较高，有严格的标准
- `Array.of()` 将一组数值转为数组

### 对象扩展

- es6 允许再大括号内，直接写入变量和函数，作为对象的属性和方法，用于函数的返回值
- 属性名表达式，允许字面量定义对象，用表达式作为对象的属性名，就是把标达式放在括号内
- 对象的扩展运算符，三个点，相当于将对象展开

### 函数扩展

- 箭头函数，es6 允许使用箭头 `=>` 定义函数
  - 箭头函数如果不需要参数或者需要多个参数，就使用一个圆括号代表参数部分
  - 如果箭头函数的代码块部分多于一条语句，就使用大括号将它们括起来，使用 `return` 返回
  - 箭头函数的作用就是简化回调函数
  - 对于普通函数，内部的 `this` 指向函数运行时所在的对象，但是对于箭头函数，内部的 `this` 就是定义时上层作用域中的 `this` ，箭头函数没有自己的 `this` 只能调用上层的 `this`

### Set

- es6 提供了新的数据结构 `Set` ，类似于数组，但是成员的数值是唯一的，没有重复的值
- `Set` 本身是一个构造函数，用来生成 `Set` 数据结构
- 通过 `add` 方法加入成员，而且 `Set` 不会添加重复的值
- 可以接收一个数组作为参数
- 可以用作数组去除重复项的方法
- 字符串去除重复字符
- 加入值时，数据类型不会发生转换，所以字符和数字是会分别的
- `size` 返回实例的成员总数
- `add()` 添加元素
- `delete()` 删除某个值，返回一个布尔值，表示删除操作是否成功
- `has()` 是否有某个元素
- `clear()` 清除所有元素

### promise

是异步编程的一种解决办法， `Promise` 是一个对象，从它可以获取异步操作的消息

有三种 `promise` 状态，除了异步操作的结果，任何其他操作都无法改变这个状态，只有从 `pending` 变为 `fulfilled` 和从 `pending` 变为 `rejected` 的状态改变。只要处于 `fulfilled` 和 `rejected` ，状态就不会再变了即 `resolved`

- `pending` 进行中
- `fulfilled` 已成功
- `rejected` 已失败

**缺点**

- 无法取消 `Promise` ，一旦新建它就会立即执行，无法中途取消
- 如果不设置回调函数， `Promise` 内部抛出的错误，不会反应到外部
- 当处于 `pending` 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

**then方法**

- 接收两个函数作为参数，第一个参数是 `Promise` 执行成功时的回调，第二个参数是 `Promise` 执行失败时的回调，两个函数只会有一个被调用
- 当事件队列的当前运行完成之前，回调函数永不会被调用，
- `then` 方法可以返回值作为下一个链式反应的值
- 当忘记返回值时，对应链条被打破，导致之后的链式反应与当前链式反应同时进行
- 大多数浏览器中不能终止的 `Promise` 链里的 `rejection` ，建议后面都跟上 `.catch(error => console.log(error));`

### Async函数

使得异步操作更方便，可以把异步操作变为同步操作，但是需要使用 `await` 关键字来等待异步操作完成，以此来实现同步

### 类的使用

`js` 中，生成实例对象的传统方法是通过构造函数来实现，在 `es6` 中引入了 `class` ，通过这个关键字可以定义类

- 实例化需要使用 `new` 来实现
- 类不存在提升，也就是只能在声明之后使用

**实例的属性**

是指类的对象实例可以调用的属性，一般就是在构造函数中所声明并且定义的属性

**静态方法**

所有在类中定义的方法都会被实例继承，但是对于 `static` 方法不会被实例继承，但是可以直接调用，而实例中却没有此方法，如果静态方法中包含 `this` 那这个就是指这个类，而不是实例

**静态属性**

就是 `class` 本身的属性，也就是 `Class.propname` ，这个可以在类之外定义，但是不会被实例继承

### module语法

`js` 没有将一个大的程序拆分成一些相互有依赖关系的小文件，再用简单的方式拼接起来，但是在 `es6` 中引入了 `module` 方法来实现此功能

先通过 `export` 指令显示指定来自外部的代码，再通过 `import` 命令输入

```es6
export var hello = "hello";
import{hello} form "./hello.js";
```

测试需要采用 `Nodejs` 的方式测试 `module` 语法
